{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module PostgresVis.Parse where

import Protolude hiding (many, try)

import Control.Foldl (Fold(..))
import qualified Control.Foldl as F
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified Data.Text as Text
import Text.Megaparsec
import Text.Megaparsec.Char

type Parser a = Parsec Void Text a

newtype Table = Table Text
  deriving (Show, Eq, Ord, Hashable, Generic)

data ForeignKey
  = ForeignKey { getConstrainedTable :: !Table
               , getReferencedTable :: !Table
               }
  deriving (Eq, Show, Ord)

-- | Maps table that has FK constraint to the table being referenced.
type ForeignKeys = Map Table (Set Table)

data Schema = Schema (Set Table) ForeignKeys
  deriving (Show)

test :: IO ()
test = do
  input <- readFile "/home/alex/Downloads/schema.sql"
  case parseSchema input of
    Left e -> putText $ show e
    Right (Schema tables fks) -> do
      mapM_ (putText . show) tables
      void $ Map.traverseWithKey (\x rs -> mapM_ (putText . show) . map (ForeignKey x) . Set.toList $ rs) fks
  
-- | Parse the output of "pg_dump -s"
parseSchema :: Text -> Either (ParseErrorBundle Text Void) Schema
parseSchema input = runParser sqlFile "schema" input

data Item = TableItem Table
          | ForeignKeyItem ForeignKey
  deriving (Show, Eq, Ord)

-- Doesn't support all PSQL syntax by any means. The parser may even break
-- due to formatting issues. This is really just meant to parse exactly the file
-- generated by 'pg_dump -s'.
sqlFile :: Parser Schema
sqlFile = do
  items <- tableOrForeignKey
  pure $ F.fold (Schema <$> tableFold <*> fkFold) items
  where
    tableStep accum (TableItem table) = Set.insert table accum
    tableStep accum (ForeignKeyItem fk) = accum
    fkStep accum (ForeignKeyItem fk) =
      Map.insertWith (<>) (getConstrainedTable fk) (Set.singleton $ getReferencedTable fk) accum
    fkStep accum _ = accum
    tableFold = Fold tableStep mempty identity
    fkFold = Fold fkStep mempty identity

-- | Skip until next table or foreign key definition, and parse it.
tableOrForeignKey :: Parser [Item]
tableOrForeignKey = catMaybes <$> many itemOrIrrelevantLine
  where
    itemOrIrrelevantLine = (Just <$> (try table <|> try foreignKey)) <|> (skipToNextLine $> Nothing)
  
table :: Parser Item
table = do
  void $ string "CREATE TABLE " >> schema
  name <- doubleQuotedText1
  skipToNextLine
  pure $ TableItem $ Table name

schema :: Parser ()
schema = void $ takeWhile1P (Just "schema") (/= '.') >> char '.'

doubleQuotedText1 :: Parser Text
doubleQuotedText1 = between (char '"') (char '"') ((takeWhile1P Nothing (/= '"')) <?> "non-empty text")

textInParens :: Parser Text
textInParens = between (char '(') (char ')') (takeWhileP Nothing (/= ')'))

skipToNextLine :: Parser ()
skipToNextLine = do
  void $ takeWhileP Nothing (/= '\n') -- \r\n will break things, but I don't care
  void eol
  
foreignKey :: Parser Item
foreignKey = do
  tableWithConstraint <-
    string "ALTER TABLE " >> optional (string "ONLY ") >> schema >> doubleQuotedText1
  void $ space >> string "ADD CONSTRAINT " >> doubleQuotedText1 >> space >> string "FOREIGN KEY "
  referencedTable <- textInParens >> space >> string "REFERENCES " >> schema >> doubleQuotedText1
  pure $ ForeignKeyItem $ ForeignKey (Table tableWithConstraint) (Table referencedTable)
    
  
